---
author: jiunkoo
title: 자바 - 객체 지향 설계 5원칙
date: 2023-09-05 23:10:00 +0900
---

<br/>
<br/>

## 1. SOLID 원칙은 무엇인가?

SOLID 원칙은 좋은 객체지향 설계를 위한 다섯 가지 원칙의 앞 머리 알파벳을 따서 정의한 단어다. 로버트 C. 마틴(Robert C. Martin)이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 마이클 페더스(Michalel Feathers)가 두문자어로 소개한 것에서 유래했다.<br/>

* **S**RP(Single Responsibility Principle, 단일 책임 원칙)
* **O**CP(Open Closed Principle, 개방 폐쇄 원칙)
* **L**SP(Liskov Substitution Principle, 리스코프 치환 원칙)
* **I**SP(Interface Segregation Principle, 인터페이스 분리 원칙)
* **D**IP(Dependency Inversion Principle, 의존관계 역전 원칙)

프로그램에 SoC를 적용하면 SOLID 원칙을 지키는 프로그램을 만들 수 있다. SoC(Separation Of Concerns, 관심사의 분리)는 관심이 같은 것끼리 모으고 관심이 다른 것은 분리하는 것이다.<br/>

<br/>
<br/>

## 2. 결합도와 응집도

좋은 소프트웨어 설계를 위해선 결합도를 낮추고 응집도를 올려야 한다.<br/>

* 결합도(Coupling): 모듈 간의 연관(의존) 정도
    * 모듈이 의존적일 수록 결합도가 높고 독립적일 수록 결합도가 낮음
        * 결합도가 높으면 A 모듈을 변경했을 때 B 모듈도 변경할 게 많음
        * 결합도가 낮으면 A 모듈을 변경했을 때 B 모듈에 변경할 게 적음
* 응집도(Cohension): 모듈 내부 구성 요소의 연관(의존) 정도
    * 모듈이 하나의 책임을 수행하면 응집도가 높고 다양한 책임을 수행하면 응집도가 낮음
        * 응집도가 높으면 모듈이 하나의 책임에 집중해서 변경할 게 적음
        * 응집도가 낮으면 모듈이 여러 책임에 집중해서 변경할 게 많음

결합도가 낮고 응집도가 높은 프로그램 설계는 다음과 같은 장점을 가진다.<br/>

* 높은 재사용성: 다른 프로젝트에서도 이미 구현한 기능이 필요한 경우 해당 모듈을 호출해서 사용할 수 있음
* 유지보수/테스트의 용이함: 각 모듈은 독립적으로 동작하므로 변경 사항이 발생할 때 특정 모듈만 수정/테스트 가능
* 개발 생산성 향상: 프로그램을 개발할 때 모듈 별로 분업이 가능하므로 개발 시간 단축 및 생산성 향상

<br/>
<br/>

## 3. SRP - 단일 책임 원칙

<div class="adm-note-lang lang-bold">
  <div class="adm-title-note-lang">로버트 C. 마틴</div>
  <p>어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.</p>
</div>

SRP(Single Responsibility Principle, 단일 책임 원칙)는 하나의 클래스가 하나의 책임만 가져야 한다는 원칙이다.<br/>

* SRP 원칙을 준수하는 경우
    * 하나의 책임에 집중하므로 **응집도가 높음**
    * 다른 클래스에 의존하지 않으므로 **결합도가 낮음**
* SRP 원칙을 위배하는 경우
    * 여러 책임에 집중하므로 **응집도가 낮음**
    * 다른 클래스에 의존하므로 **결합도가 높음**

<br/>
<br/>

## 4. OCP - 개방 폐쇄 원칙

<div class="adm-note-lang lang-bold">
  <div class="adm-title-note-lang">로버트 C. 마틴</div>
  <p>소프트웨어 엔티티(클래스, 모듈, 함수 등)은 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.</p>
</div>

OCP(Open Closed Principle, 개방 폐쇄 원칙)는 소프트웨어 요소가 확장에 관대하고 변경에 보수적이어야 한다는 원칙이다.<br/>

* OCP 원칙을 준수하는 경우
    * 확장에 관대하므로 확장성이 높음
    * 변경에 보수적이므로 **결합도가 낮음**
* OCP 원칙을 위배하는 경우
    * 확장에 보수적이므로 확장성이 낮음
    * 변경에 관대하므로 **결합도가 높음**

<br/>
<br/>

## 5. LSP - 리스코프 치환 원칙

<div class="adm-note-lang lang-bold">
  <div class="adm-title-note-lang">로버트 C. 마틴</div>
  <p>서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.</p>
</div>

LSP(Liskov Substitution Principle, 리스코프 치환 원칙)은 서브 타입을 기반 타입으로 교체할 수 있어야 한다는 원칙이다.<br/>

* LSP 원칙을 준수하는 경우
    * 서브 타입을 기반 타입으로 교체할 수 있어 다형성을 만족하므로 **결합도가 낮음**
    * 다형성을 만족하고 기반 타입과 서브 타입의 관계가 명확하므로 **응집도가 높음**
* LSP 원칙을 위배하는 경우
    * 서브 타입을 기반 타입으로 교체할 수 없어 각각의 클래스에 의존적이며 **결합도가 높음**
    * 다형성을 만족하지 못하고 기반 타입과 서브 타입의 관계가 불명확하므로 **응집도가 낮음**

<br/>
<br/>

## 6. ISP - 인터페이스 분리 원칙

<div class="adm-note-lang lang-bold">
  <div class="adm-title-note-lang">로버트 C. 마틴</div>
  <p>클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.</p>
</div>

ISP(Interface Segregation Principle, 인터페이스 분리 원칙)은 한 개의 범용 인터페이스보다 클라이언트의 요구에 맞게 세분화된 인터페이스가 바람직하다는 원칙이다. 이는 클라이언트가 자신이 사용하는 메서드에만 의존 관계를 맺어야 한다는 뜻이다.<br/>

* ISP 원칙을 준수하는 경우
    * 세분화된 인터페이스는 각각 한 개의 책임에 집중하므로 **응집도가 높음**
    * 인터페이스의 구현이 독립적이므로 **결합도가 낮음**
* ISP 원칙을 위배하는 경우
    * 범용 인터페이스는 여러 책임에 집중하므로 **응집도가 낮음**
    * * 분산된 책임으로 인해 여러 모듈이 범용 인터페이스에 의존하므로 **결합도가 높음**

<br/>
<br/>

## 7. DIP - 의존관계 역전 원칙

<div class="adm-note-lang lang-bold">
  <div class="adm-title-note-lang">로버트 C. 마틴</div>
  <p>
    고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈은 모두 다른 추상화된 것에 의존해야 한다.<br/>
    추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.<br/>
    자주 변경되는 구체(concrete) 클래스에 의존하지 마라.
  </p>
</div>

DIP(Dependency Inversion Principle)은 구체화가 아닌 추상화에 의존해야 한다는 원칙이다. 이는 자신보다 변하기 쉬운 것에 의존하지 마라는 뜻이다.<br/>

* DIP 원칙을 준수하는 경우
    * 추상화된 인터페이스나 추상 클래스에 의존하므로 **결합도가 낮음**
* DIP 원칙을 위배하는 경우
    * 구체화된 클래스에 의존하므로 **결합도가 높음**

<br/>
<br/>

<div class="adm-reference">
    <div class="adm-title-reference">참고 자료</div>
    <ul>
        <li>스프링 입문을 위한 자바 객체 지향의 원리와 이해 - 위키북스</li>
    </ul>
</div>
